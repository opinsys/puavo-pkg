#!/usr/bin/ruby1.9.1

require 'fileutils'
require 'getoptlong'
require 'json'
require 'open3'
require 'resolv'
require 'syslog'

def print_help()
   puts <<-EOF
puavo-pkg-updater [OPTIONS]

-h, --help                 show help

    --update-installers    fetch and extract new puavo-pkg installers bundle
    --upgrade-packages     upgrade all installed (puavo-pkg) packages
  EOF
end

def syslog(channel, priority, *args)
  Syslog.log(priority, *args)
  channel.printf(*args)
end

def log(*args)   ; syslog(STDOUT, *args); end
def logerr(*args); syslog(STDERR, *args); end

def run(*args)
  system(*args) or raise "Running system command #{ args } returned failure"
end

def lookup_imageservers()
  imageservers = []

  puavo_domain = IO.read('/etc/puavo/domain').chomp

  begin
    imageservers \
      << Resolv::DNS.new.getresource("_imageserver._tcp.#{ puavo_domain }",
                                    Resolv::DNS::Resource::IN::SRV) \
           .target.to_s
  rescue Resolv::ResolvError
    log(Syslog::LOG_INFO, "could not find the image server from DNS\n")
  end

  device = JSON.parse( IO.read('/state/etc/puavo/device.json') )

  # XXX not used yet, it is unclear if this will ever be?
  if device['imageservers'].kind_of?(Array) then
    imageservers += device['imageservers']
  end

  topdomain = IO.read('/etc/puavo/topdomain').chomp
  imageservers << "images.#{ topdomain }"

  log(Syslog::LOG_INFO,
      "using image servers: %s\n",
      imageservers.join(' '))

  imageservers
end

def fetch_installer_bundle(remote_bundlepath, local_bundlepath)
  imageservers = lookup_imageservers()

  imageservers.each do |server|
    uri = "https://#{ server }/#{ remote_bundlepath }"

    FileUtils.mkdir_p( File.dirname(local_bundlepath) )
    wget_ok = system('wget', '--ca-certificate=/etc/puavo/certs/rootca.pem',
                             "--output-document=#{ local_bundlepath }",
                             '--timestamping',
                             uri,
                             { :out => '/dev/null',
                               :err => '/dev/null', })
    if !wget_ok then
      logerr(Syslog::LOG_WARNING,
             "failed to fetch %s from %s\n",
             remote_bundlepath,
             server)
      next
    end

    log(Syslog::LOG_INFO, "fetched %s from %s\n", remote_bundlepath, server)
    return
  end

  raise "Failed to fetch #{ remote_bundlepath } from imageservers"
end

def get_config()
  JSON.parse( IO.read('/etc/puavo-pkg/puavo-pkg-updater.conf') )
end

def flock_licenses_json(installers_dir)
  licenses_json_path = "#{ installers_dir }/installers/licenses.json"

  begin
    licenses_json_file = File.open(licenses_json_path)

    # Get exclusive lock on licenses.json, because we are going to update that.
    if licenses_json_file.flock(File::LOCK_EX|File::LOCK_NB) then
      return [ 'LOCK', licenses_json_file ]
    end

    # If someone else has a lock, we will exit with no failure, because
    # even though we could not do an update, things should be okay.
    log(Syslog::LOG_NOTICE,
        "Something is holding a lock on %s,\n" \
          + "not updating puavopkg installers.\n",
        licenses_json_path)
    licenses_json_file.close
    [ 'LOCKHELD', nil ]
  rescue Errno::ENOENT
    # If file does not exist, we go without a lock,
    # because we are going to create that file.
  end

  [ 'NOLOCK', nil ]
end

def unpack_installers(local_bundlepath, installers_dir)
  latest_changetime = File.stat(local_bundlepath).mtime

  current_installersdir \
    = "#{ installers_dir }/installers.#{ latest_changetime.to_i }"

  # We flock the licenses.json file so that puavo-local-config-ui can depend on
  # its software list and urls to be current with the contents of installer
  # directories.
  lockstatus, licenses_json_file = * flock_licenses_json(installers_dir)
  return if lockstatus == 'LOCKHELD'

  if !File.directory?(current_installersdir) then
    log(Syslog::LOG_INFO, "Unpacking updated puavo-pkg installers\n")

    current_installers_tmpdir = "#{ current_installersdir }.tmp"

    FileUtils.mkdir_p(current_installers_tmpdir)
    run('tar', '-C', current_installers_tmpdir,
               '--no-same-owner',
               '--no-same-permissions',
               '-x',
               '-f', local_bundlepath)

    make_licenses_info_file(current_installers_tmpdir)

    FileUtils.mv(current_installers_tmpdir, current_installersdir)
  end

  installerslinkpath = "#{ installers_dir }/installers"
  current_linktarget = File.readlink(installerslinkpath) rescue nil
  new_linktarget = File.basename(current_installersdir)
  if current_linktarget != new_linktarget then
    log(Syslog::LOG_INFO, "Updating link to new puavo-pkg installers\n")
    File.symlink(new_linktarget, "#{ installerslinkpath }.tmp")
    File.rename("#{ installerslinkpath }.tmp", installerslinkpath)
  end

  if licenses_json_file then
    # flock(File::LOCK_UN) as a side effect when needed
    licenses_json_file.close
  end

  # clean up old installer bundles
  Dir.glob("#{ installers_dir }/installers.*") do |dir|
    next if dir == current_installersdir
    log(Syslog::LOG_INFO, "Removing old installers at %s\n", dir)
    FileUtils.remove_entry_secure(dir, true)
  end
end

def make_licenses_info_file(current_installers_tmpdir)
  licenses = {}

  Dir.glob("#{ current_installers_tmpdir }/*.tar.gz") do |tarpath|
    pkgname = File.basename(tarpath, '.tar.gz')
    license_url, status = Open3.capture2('puavo-pkg', 'license', tarpath)
    if status.exitstatus != 0 then
      log(Syslog::LOG_ERR,
          "puavo-pkg license %s returned error code: %d\n",
          tarpath,
          status.exitstatus)
      next
    end

    licenses[pkgname] = license_url.chomp
  end

  licenses_path = "#{ current_installers_tmpdir }/licenses.json"

  tmpfile = "#{ licenses_path }.tmp"
  File.open(tmpfile, 'w') { |f| f.print(licenses.to_json) }
  File.rename(tmpfile, licenses_path)
end

def update_installers(config)
  remote_bundlepath = config['bundlepath']
  installers_dir    = config['installers_dir']

  local_bundlepath = "#{ installers_dir }/puavo-pkg-installers-bundle.tar"

  fetch_installer_bundle(remote_bundlepath, local_bundlepath)

  unpack_installers(local_bundlepath, installers_dir)
end

def upgrade_packages(config)
  # XXX unimplemented
end

update_installers = false
upgrade_packages  = false

begin
  opts = GetoptLong.new(
           [ '--help', '-h',        GetoptLong::NO_ARGUMENT, ],
           [ '--update-installers', GetoptLong::NO_ARGUMENT, ],
           [ '--upgrade-packages',  GetoptLong::NO_ARGUMENT, ])

  opts.each do |opt, arg|
    case opt
      when '--help'
        print_help()
        exit(0)
      when '--update-installers'
        update_installers = true
      when '--upgrade-packages'
        upgrade_packages = true
    end
  end
rescue GetoptLong::InvalidOption => e
  print_help()
  exit(1)
end

unless update_installers || upgrade_packages; then
  print_help()
  exit(1)
end

Syslog.open(File.basename($0), Syslog::LOG_CONS)

begin
  config = get_config()
  if update_installers
    update_installers(config)
  end
  if upgrade_packages
    upgrade_packages(config)
  end
ensure
  Syslog.close()
end

exit(0)
