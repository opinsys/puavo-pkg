#!/bin/bash
# Copyright (C) 2015 Opinsys Oy
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

g_puavo_pkg_rootdir=/var/lib/puavo-pkg/packages
g_puavo_img_filename=noimage

print_help_and_exit()
{
    echo "Usage: puavo-pkg [OPTIONS] [COMMAND] [COMMAND_ARGS]"
    echo
    echo "Package manager for Puavo packages."
    echo
    echo "Options:"
    echo "  -h, --help                   print this help and exit"
    echo
    echo "      --package-root-dir DIR   use DIR as the root, defaults"
    echo "                               to ${g_puavo_pkg_rootdir}"
    echo
    echo "Commands:"
    echo "  install INSTALLER            install package with an installer"
    echo
    echo "  license INSTALLER|PACKAGE    print license URL"
    echo
    echo "  list                         list installed packages"
    echo
    echo "  reconfigure PACKAGE          reconfigure installed PACKAGE"
    echo "  reconfigure --all            reconfigure all installed packages"
    echo
    echo "  remove PACKAGE               remove installed PACKAGE"
    echo "  remove --all                 remove all installed package"
    echo
    exit 0
}

log_error()
{
    local message=$1

    echo "ERROR: $1" >&2
}

log_info()
{
    local message=$1

    echo "INFO: $1" >&2
}

list_configured_packages()
{
    find "${g_puavo_pkg_rootdir}"       \
        -maxdepth 2                     \
        -mindepth 2                     \
        -type l                         \
        -name "${g_puavo_img_filename}" \
        -exec readlink -z -e {} \;      \
        | while read -d '' package_dir; do
        local package_name=$(get_package_name "${package_dir}") || return 1
        echo "${package_name}" || return 1
    done
}

get_license_url()
{
    local identifier=$1
    local INSTALLER_REGEX='\.tar\.gz$'

    if [[ "${identifier}" =~ ${INSTALLER_REGEX} ]]; then
        local package_dir=$(extract_installer "${identifier}") || {
            log_error "failed to extract installer '${identifier}'"
            return 1
        }
    else
        local package_dir=$(get_configured_package_dir "${identifier}") || return 1
    fi

    [ -f "${package_dir}/license" ] && echo "file://${package_dir}/license"
}

get_package_basedir()
{
    local package_name=$1
    echo "${g_puavo_pkg_rootdir}/${package_name}"
}

get_package_link()
{
    local package_name=$1
    local package_basedir=$(get_package_basedir "${package_name}") || return 1

    echo "${package_basedir}/${g_puavo_img_filename}"
}

get_package_dir()
{
    local package_name=$1
    local package_version=$2
    local package_basedir=$(get_package_basedir "${package_name}") || return 1

    echo "${package_basedir}/${package_version}"
}

get_configured_package_dir()
{
    local package_name=$1
    local package_link=$(get_package_link "${package_name}") || return 1

    readlink -e "${package_link}" || true
}

get_configured_package_version()
{
    local package_name=$1
    local package_dir=$(get_configured_package_dir "${package_name}") || return 1

    [ -n "${package_dir}" ] || return 0

    basename "${package_dir}"
}

get_package_name()
{
    local package_dir=$1
    local package_basedir=$(dirname "${package_dir}") || return 1

    basename "${package_basedir}"
}

get_package_version()
{
    local package_dir=$1

    basename "${package_dir}"
}

configure_package()
{
    local package_name=$1
    local package_version=$2
    local package_dir=$(get_package_dir "${package_name}" "${package_version}") || return 1
    local upstream_dir="${package_dir}/upstream"
    local configured_package_dir=$(get_configured_package_dir "${package_name}") || return 1
    local package_link=$(get_package_link "${package_name}") || return 1

    if [ -n "${configured_package_dir}" ]; then
        if [ "${configured_package_dir}" != "${package_dir}" ]; then
            log_error "another version of the package has already been " \
                "configured, unconfigure it before proceeding"
            return 1
        fi
    fi

    pushd "${package_dir}" >/dev/null || return 1
    ./rules configure "${upstream_dir}" || {
        popd >/dev/null || true
        log_error "failed to configure package '${package_name}'"
        return 1
    }
    popd >/dev/null || return 1

    ln -sf "${package_version}" "${package_link}" || {
        log_error "failed to create a package link"
        return 1
    }

    log_info "${package_name}: configured succesfully" || true
}

reconfigure_package()
{
    local package_name=$1
    local package_version=$(get_configured_package_version "${package_name}") || return 1

    configure_package "${package_name}" "${package_version}"
}

reconfigure_all_packages()
{
    local packages=$(list_configured_packages) || return 1
    local retval=0

    for package in ${packages}; do
        reconfigure_package "${package}" || retval=1
    done

    return ${retval}
}

unconfigure_package()
{
    local package_name=$1
    local package_link=$(get_package_link "${package_name}") || return 1
    local package_dir=$(readlink -e "${package_link}") || true
    local upstream_dir="${package_dir}/upstream"

    [ -n "${package_dir}" ] || return 0

    pushd "${package_dir}" >/dev/null || return 1
    ./rules unconfigure "${upstream_dir}" >/dev/null || {
        popd >/dev/null || true
        log_error "failed to unconfigure package '${package_name}'"
        return 1
    }
    popd >/dev/null || return 1

    rm -f "${package_link}" || return 1

    log_info "${package_name}: unconfigured succesfully"
    echo "${package_dir}"
}

unpack_upstream_pack()
{
    local package_name=$1
    local package_version=$2
    local package_dir=$(get_package_dir "${package_name}" "${package_version}") || return 1
    local upstream_pack="${package_dir}/upstream_pack"
    local upstream_dir="${package_dir}/upstream"
    local upstream_tmpdir="${upstream_dir}.tmp"

    if [ -d "${upstream_dir}" ]; then
        return 0
    fi

    check_md5sum "${package_dir}/upstream_pack_md5sum" "${upstream_pack}" || {
        log_error "upstream pack has incorrect checksum, " \
            "perhaps you should purge the package and download it again?"
        return 1
    }

    rm -rf "${upstream_tmpdir}"
    mkdir "${upstream_tmpdir}" || return 1

    pushd "${package_dir}" >/dev/null || return 1
    ./rules unpack "${upstream_pack}" "${upstream_tmpdir}" || {
        popd >/dev/null || true
        rm -rf "${upstream_tmpdir}"
        return 1
    }
    popd >/dev/null || {
        rm -rf "${upstream_tmpdir}"
        return 1
    }

    mv -T "${upstream_tmpdir}" "${upstream_dir}" || {
        rm -rf "${upstream_tmpdir}"
        return 1
    }

    log_info "${package_name}: unpacked upstream pack succesfully"
}

check_md5sum()
{
    local md5sum_file=$1
    local file=$2

    [ -r "${file}" ] || return 1

    [ -r "${md5sum_file}" ] || return 0
    local md5sum_str=$(cat "${md5sum_file}") || return 1

    md5sum --check --status 2>/dev/null <<<"${md5sum_str}  ${file}"
}

download_upstream_pack()
{
    local package_name=$1
    local package_version=$2
    local package_dir=$(get_package_dir "${package_name}" "${package_version}") || return 1
    local upstream_pack="${package_dir}/upstream_pack"
    local upstream_tmppack="${upstream_pack}.tmp"

    if check_md5sum "${package_dir}/upstream_pack_md5sum" "${upstream_pack}"; then
        return 0
    fi

    if [ ! -r "${package_dir}/upstream_pack_url" ]; then
        pushd "${package_dir}" >/dev/null || return 1
        ./rules download "${upstream_tmppack}" || {
            popd >/dev/null || true
            rm -rf "${upstream_tmppack}" || true
            log_error "package downloader returned an error!"
            return 1
        }
        popd >/dev/null || {
            rm -rf "${upstream_tmppack}"
            return 1
        }
    else
        wget \
            --no-use-server-timestamps \
            --no-check-certificate \
            --no-cookies \
            --input-file "${package_dir}/upstream_pack_url" \
            --output-document "${upstream_tmppack}" || {
            rm -rf "${upstream_tmppack}"
            return 1
        }
    fi

    check_md5sum "${package_dir}/upstream_pack_md5sum" "${upstream_tmppack}" || {
        log_error "downloaded upstream pack has incorrect checksum"
        rm -rf "${upstream_tmppack}"
        return 1
    }

    mv -T "${upstream_tmppack}" "${upstream_pack}" || {
        rm -rf "${upstream_pack}"
        return 1
    }

    log_info "${package_name}: downloaded upstream pack succesfully"
}

get_md5sum()
{
    local file=$1
    local output=$(md5sum "${file}") || return 1

    awk '{print $1}' <<<"${output}"
}

extract_installer()
{
    local installer=$1
    local package_name=$(basename "${installer}" .tar.gz) || return 1
    local package_version=$(get_md5sum "${installer}") || return 1

    local package_dir=$(get_package_dir "${package_name}" "${package_version}")
    local package_tmpdir="${package_dir}.tmp"

    if [ -d "${package_dir}" ]; then
        echo "${package_dir}"
        return
    fi

    mkdir -p "${package_tmpdir}" || return 1

    tar --no-same-owner --no-same-permissions --strip-components=1 \
        -z -x -f "${installer}" -C "${package_tmpdir}"  || {
        rm -rf "${package_tmpdir}"
        return 1
    }

    mv -T "${package_tmpdir}" "${package_dir}" || {
        rm -rf "${package_tmpdir}"
        return 1
    }

    log_info "${package_name}: extracted installer file succesfully"

    echo "${package_dir}"
}

install_package_with_installer()
{
    local installer=$1
    local package_dir=$(extract_installer "${installer}") || {
        log_error "failed to extract '${installer}'"
        return 1
    }

    local package_name=$(get_package_name "${package_dir}") || return 1
    local package_version=$(get_package_version "${package_dir}") || return 1

    download_upstream_pack "${package_name}" "${package_version}" || {
        log_error "failed to download the upstream pack of package '${package_name}'"
        return 1
    }

    unpack_upstream_pack "${package_name}" "${package_version}" || {
        log_error "failed to unpack the upstream pack of package '${package_name}'"
        return 1
    }

    unconfigure_package "${package_name}" >/dev/null || {
        log_error "failed to unconfigure package '${package_name}'"
        return 1
    }

    configure_package "${package_name}" "${package_version}" || {
        log_error "failed to configure package '${package_name}' of version '${package_version}'"
        return 1
    }

    log_info "${package_name}: installed succesfully"
}

remove_package()
{
    local package_name=$1

    local package_dir=$(unconfigure_package "${package_name}") || {
        log_error "failed to unconfigure package '${package_name}'"
        return 1
    }

    if [ -n "${package_dir}" ]; then
        rm -rf "${package_dir}" || return 1
        log_info "removed package '${package_name}'"
        return 0
    fi

    log_error "package '${package_name}' is not installed"
    return 1
}

remove_all_packages()
{
    local packages=$(list_configured_packages) || return 1
    local retval=0

    for package in ${packages}; do
        remove_package "${package}" || retval=1
    done

    return ${retval}
}

usage_error()
{
    local message=$1

    log_error "${message}"
    echo "Try 'puavo-pkg --help' for more information." >&2
    return 1
}

assert_args_count()
{
    local op=$1
    local count=$2
    shift 2

    if [ ! $# ${op} "${count}" ]; then
        usage_error "invalid number of arguments ($#), expected ${count}"
        return
    fi
}

## Main begins.

set -eu

while [ $# -gt 0 ]; do
    case $1 in
        -h|--help)
            shift
            print_help_and_exit
            ;;
        --package-root-dir)
            shift
            assert_args_count -ge 1 "$@"
            g_puavo_pkg_rootdir=$1
            shift
            ;;
        --)
            shift
            break
            ;;
        -*)
            usage_error "invalid argument '$1'"
            ;;
        *)
            break
            ;;
    esac
done

if [ $# -lt 1 ]; then
    print_help_and_exit
fi

mkdir -p "${g_puavo_pkg_rootdir}"

if [ -f /etc/ltsp/this_ltspimage_name ]; then
    read g_puavo_img_filename </etc/ltsp/this_ltspimage_name
fi

command=$1
shift

case "${command}" in
    install)
        assert_args_count -eq 1 "$@"
        install_package_with_installer "$1"
        ;;
    license)
        assert_args_count -eq 1 "$@"
        get_license_url "$1"
        ;;
    list)
        assert_args_count -eq 0 "$@"
        list_configured_packages
        ;;
    reconfigure)
        assert_args_count -eq 1 "$@"
        if [ "$1" = '--all' ]; then
            reconfigure_all_packages
        else
            reconfigure_package "$1"
        fi
        ;;
    remove)
        assert_args_count -eq 1 "$@"
        if [ "$1" = '--all' ]; then
            remove_all_packages
        else
            remove_package "$1"
        fi
        ;;
    *)
        usage_error "unknown command '${command}'"
esac

exit 0
